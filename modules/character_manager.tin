#ACTION {%*(PAGES LEFT: %d):$}
{
     #if {{$MSDP_POSITION} == {Menu}}
     {
          #nop {Send a carriage return, since you can't do any command until you page all the way.};
          #cr
     }
}
{9}

#ACTION {^You will not try to fight from ranged combat distance.  You will still need to ADVANCE on opponents who are attempting to use ranged combat in order to hit them.$}
{
     #if {$checkingRanged}
     {
          #line gag;
          ranged
     }
}
{9}


#ALIAS {^CSAVE$}
{
     #if {{$MSDP_CHARACTER_NAME} != {} && {$MSDP_POSITION} != {Menu} && {$MSDP_CHARACTER_NAME} != {\$MSDP_CHARACTER_NAME}}
     {
          #variable {historyPath} {${HOME}/${MSDP_CHARACTER_NAME}.history};
          #replace {historyPath} {\\} {};
          #history {write} {$historyPath};
          #unvariable {historyPath};
          #unvariable {MSDP_%*};
          #class {${msdpOldList[CHARACTER_NAME]}} {write} {${HOME}/${msdpOldList[CHARACTER_NAME]}};
          #class {${msdpOldList[CHARACTER_NAME]}} {close};
          #variable {copying} {1};
          #local {i} {};
          #foreach {*{msdpOldList[]}} {i}
          {
               #variable {MSDP_$i} {${msdpOldList[$i]}}
          };
          #variable {copying} {0};
          #class {${MSDP_CHARACTER_NAME}} {open}
     }
}
{9}

#ALIAS {^bot{kill|load} %S$}
{
     #nop {character bot path};
     #variable {modpath} {${HOME}/${MSDP_CHARACTER_NAME}.bots};
     #replace {modpath} {\\} {};
     #nop {Kill, load, or reload a specified bot.};
     #if {{%1} == {kill}}
     {
          #local {exists} {@bot_%1{}};
          #variable {exists} {$exists};
          #if {{$exists} != {@%*}}
          {
               $exists
          };
          #class {bot_%2} {kill};
          #class {$MSDP_CHARACTER_NAME} {open};
          #showme {bot %2 has been killed.}
     };
     #if {{%1} == {load}}
     {
          #showme {Loading bot %2.tin};
          #class {$MSDP_CHARACTER_NAME} {close};
          #class {bot_%2} {read} {$modpath/%2.tin};
          #local {exists} {@bot_%1{}};
          #variable {exists} {$exists};
          #if {{$exists} != {@%*}}
          {
               $exists
          }
     };
     #unvariable {modpath}
}
{9}

#ALIAS {^cmod{kill|load|reload} %S$}
{
     CSAVE;
     #nop {character module path};
     #variable {modpath} {${HOME}/${MSDP_CHARACTER_NAME}.modules};
     #replace {modpath} {\\} {};
     #nop {reload all modules};
     #if {{%0} == {cmodreload all}}
     {
          #script {for module in $modpath/*.tin ; do echo "#class {$(basename "$module" .tin)} {kill};#class {character_$(basename "$module" .tin)} {read} {$module}";done};
          #script {if [ -d "$HOME/modules" ]; then for module in $HOME/modules/*.tin ; do echo "#class {$(basename "$module" .tin)} {kill};#class {character_$(basename "$module" .tin)} {read} {$module}";done;fi};
          #echo {{%s} {1}} {All character modules reloaded}
     };
     #else
     {
          #nop {Kill, load, or reload a specified module.};
          #if {{%1} == {{kill|reload}}}
          {
               #class {character_%2} {kill};
               #echo {{%s} {1}} {Character module %2 has been killed.}
          };
          #if {{%1} == {{load|reload}}}
          {
               #echo {{%s} {1}} {Loading character module %2.tin};
               #script {if [ -r "$HOME/modules/%2.tin" ]; then echo "#class {character_%2} {read} {$HOME/modules/%2.tin}";elif [ -r "$modpath/%2.tin" ]; then echo "#class {character_%2} {read} {$modpath/%2.tin}";else echo "#echo {Character module %2.tin not found.}";fi};
               #class {$MSDP_CHARACTER_NAME} {open}
          }
     };
     #unvariable {modpath}
}
{9}

#ALIAS {^container %s%w$}
{
     #variable {character[container]} {%2};
     #echo {Your container is now %2.}
}
{9}

#ALIAS {^q{f|ff|ffe|ffec|ffect|ffects}$}
{
     #local {i} {};
     #foreach {*{MSDP_AFFECTS[]}} {i}
     {
          #regexp {$i} {{^[^0-9]+$}}
          {
               #echo {&0}
          }
     }
}
{9}

#ALIAS {^whoami$}
{
     #echo {You are $MSDP_CHARACTER_NAME, the level $MSDP_LEVEL $MSDP_CLASS ($MSDP_RACE).};
     #if {&{character.lastDeath}}
     {
          #echo {${character.lastDeath}}
     }
}
{9}

#ALIAS {^{audioprompt|beeps|noaudioprompt|nobeeps}$}
{
     #switch {{%0}}
     {
          #case {{audioprompt}}
          {
               #variable {character{audioprompt}} {1};
               #echo {Audio prompt enabled.}
          };
          #case {{beeps}}
          {
               #variable {character{beeps}} {1};
               #echo {Opponent condition beeps enabled.}
          };
          #case {{noaudioprompt}}
          {
               #variable {character[audioprompt]} {0};
               #echo {Audio prompt disabled.}
          };
          #case {{nobeeps}}
          {
               #variable {character[beeps]} {0};
               #echo {Opponent condition beeps disabled.}
          }
     }
}
{9}

#ALIAS {^{sc|sco|scor|score}$}
{
     oldscore
}
{9}



#EVENT {SESSION DISCONNECTED}
{
     CSAVE
}

#EVENT {VARIABLE UPDATE MSDP_CHARACTER_NAME}
{
     #if {{%1} != {} && !$copying}
     {
          #nop {Hook name: characterName};
          #nop {Hook args: character name.};
          #if {{${OLD_MSDP_CHARACTER_NAME}} != {} && {$OLD_MSDP_CHARACTER_NAME} != {%1}}
          {
               #variable {historyPath} {${HOME}/${OLD_MSDP_CHARACTER_NAME}.history};
               #replace {historyPath} {\\} {};
               #history {write} {$historyPath};
               #unvariable {historyPath};
               #unvariable {MSDP_%*};
               #class {${OLD_MSDP_CHARACTER_NAME}} {write} {${HOME}/${OLD_MSDP_CHARACTER_NAME}};
               #class {${OLD_MSDP_CHARACTER_NAME}} {kill};
               #variable {copying} {1};
               #local {i} {};
               #foreach {*{msdpOldList[]}} {i}
               {
                    #variable {MSDP_$i} {${msdpOldList[$i]}}
               };
               #variable {copying} {0};
               #nop {unload any old character classes};
               #variable {modpath} {${HOME}/${OLD_MSDP_CHARACTER_NAME}.modules};
               #replace {modpath} {\\} {};
               #script {for module in $(find "$modpath" -maxdepth 1 -name "*.tin") ; do echo "#class {character_$(basename "$module" .tin)} {kill}";done}
          };
          #nop {Make sure the character file exists so there's no error on read.};
          #system {if ! [ -f "$HOME/%1" ] && [ "%1" != "" ] ; then echo "#nop" > "$HOME/%1" ; fi ; if ! [ -d "$HOME/%1.modules" ] && [ "%1" != "" ] ; then mkdir "$HOME/%1.modules" ; fi ; if ! [ -d "$HOME/modules" ] ; then mkdir "$HOME/modules" ; cp modules/config.txt "$HOME/modules" ; fi};
          #variable {OLD_MSDP_CHARACTER_NAME} {%1};
          #history {read} {${HOME}/%1.history};
          #nop {clear out old sound settings};
          #unvariable {MSP};
          #nop {clear out old leader settings};
          #unvariable {leader};
          #nop {clear old hooks.};
          #unvariable {hook};
          #class {%1} {read} {${HOME}/%1};
          #nop {Load common personal modules.};
          #script {if [ -d "$HOME/modules" ]; then for module in $(find "$HOME/modules" -maxdepth 1 -name "*.tin") ; do echo "#class {character_$(basename "$module" .tin)} {read} {$module}";done;fi};
          #nop {Load personal modules.};
          #script {if [ -d "$HOME/%1.modules" ]; then for module in $(find "$HOME/%1.modules" -maxdepth 1 -name "*.tin") ; do echo "#class {character_$(basename "$module" .tin)} {read} {$module}";done;fi};
          #if {${cspam}}
          {
               #class {applied_spam_settings} {read} {modules/spam.rules};
               #echo {Client side spam filters applied.}
          };
          #class {%1} {open};
          @do_hook{charactername;%1}
     }
}

#EVENT {VARIABLE UPDATE MSDP_POSITION}
{
     #if {{%1} != {} && !$copying}
     {
          #nop {Hook name is position};
          #nop {Hook args: new position.};
          @do_hook{position;%1};
          #if {{%1} != {Menu} && {$MSDP_POSITION} == {Menu} && ${auto[range]}}
          {
               #variable {checkingRanged} {1};
               ranged;
               #delay {2} {#var {checkingRanged} {0}}
          }
     }
}



#TICKER           {csave}  {#if {{$MSDP_CHARACTER_NAME} == {$OLD_MSDP_CHARACTER_NAME}}{CSAVE}}                                          {90}

#VARIABLE         {OLD_MSDP}  {}
#VARIABLE         {checkingRanged}  {0}
#VARIABLE         {copying}  {0}

